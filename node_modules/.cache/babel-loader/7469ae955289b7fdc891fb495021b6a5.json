{"ast":null,"code":"import { createElement } from './core';\nimport ZRImage from '../graphic/Image';\nimport { DEFAULT_FONT, getLineHeight } from '../contain/text';\nimport { map } from '../core/util';\nimport { normalizeLineDash } from '../graphic/helper/dashStyle';\nvar NONE = 'none';\nvar mathRound = Math.round;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\nvar PI2 = Math.PI * 2;\nvar degree = 180 / PI;\nvar EPSILON = 1e-4;\n\nfunction round3(val) {\n  return mathRound(val * 1e3) / 1e3;\n}\n\nfunction round4(val) {\n  return mathRound(val * 1e4) / 1e4;\n}\n\nfunction isAroundZero(val) {\n  return val < EPSILON && val > -EPSILON;\n}\n\nfunction pathHasFill(style) {\n  var fill = style.fill;\n  return fill != null && fill !== NONE;\n}\n\nfunction pathHasStroke(style) {\n  var stroke = style.stroke;\n  return stroke != null && stroke !== NONE;\n}\n\nfunction setTransform(svgEl, m) {\n  if (m) {\n    attr(svgEl, 'transform', 'matrix(' + round3(m[0]) + ',' + round3(m[1]) + ',' + round3(m[2]) + ',' + round3(m[3]) + ',' + round4(m[4]) + ',' + round4(m[5]) + ')');\n  }\n}\n\nfunction attr(el, key, val) {\n  if (!val || val.type !== 'linear' && val.type !== 'radial') {\n    el.setAttribute(key, val);\n  }\n}\n\nfunction attrXLink(el, key, val) {\n  el.setAttributeNS('http://www.w3.org/1999/xlink', key, val);\n}\n\nfunction attrXML(el, key, val) {\n  el.setAttributeNS('http://www.w3.org/XML/1998/namespace', key, val);\n}\n\nfunction bindStyle(svgEl, style, el) {\n  var opacity = style.opacity == null ? 1 : style.opacity;\n\n  if (el instanceof ZRImage) {\n    svgEl.style.opacity = opacity + '';\n    return;\n  }\n\n  if (pathHasFill(style)) {\n    var fill = style.fill;\n    fill = fill === 'transparent' ? NONE : fill;\n    attr(svgEl, 'fill', fill);\n    attr(svgEl, 'fill-opacity', (style.fillOpacity != null ? style.fillOpacity * opacity : opacity) + '');\n  } else {\n    attr(svgEl, 'fill', NONE);\n  }\n\n  if (pathHasStroke(style)) {\n    var stroke = style.stroke;\n    stroke = stroke === 'transparent' ? NONE : stroke;\n    attr(svgEl, 'stroke', stroke);\n    var strokeWidth = style.lineWidth;\n    var strokeScale_1 = style.strokeNoScale ? el.getLineScale() : 1;\n    attr(svgEl, 'stroke-width', (strokeScale_1 ? strokeWidth / strokeScale_1 : 0) + '');\n    attr(svgEl, 'paint-order', style.strokeFirst ? 'stroke' : 'fill');\n    attr(svgEl, 'stroke-opacity', (style.strokeOpacity != null ? style.strokeOpacity * opacity : opacity) + '');\n    var lineDash = style.lineDash && strokeWidth > 0 && normalizeLineDash(style.lineDash, strokeWidth);\n\n    if (lineDash) {\n      var lineDashOffset = style.lineDashOffset;\n\n      if (strokeScale_1 && strokeScale_1 !== 1) {\n        lineDash = map(lineDash, function (rawVal) {\n          return rawVal / strokeScale_1;\n        });\n\n        if (lineDashOffset) {\n          lineDashOffset /= strokeScale_1;\n          lineDashOffset = mathRound(lineDashOffset);\n        }\n      }\n\n      attr(svgEl, 'stroke-dasharray', lineDash.join(','));\n      attr(svgEl, 'stroke-dashoffset', (lineDashOffset || 0) + '');\n    } else {\n      attr(svgEl, 'stroke-dasharray', '');\n    }\n\n    style.lineCap && attr(svgEl, 'stroke-linecap', style.lineCap);\n    style.lineJoin && attr(svgEl, 'stroke-linejoin', style.lineJoin);\n    style.miterLimit && attr(svgEl, 'stroke-miterlimit', style.miterLimit + '');\n  } else {\n    attr(svgEl, 'stroke', NONE);\n  }\n}\n\nvar SVGPathRebuilder = function () {\n  function SVGPathRebuilder() {}\n\n  SVGPathRebuilder.prototype.reset = function () {\n    this._d = [];\n    this._str = '';\n  };\n\n  SVGPathRebuilder.prototype.moveTo = function (x, y) {\n    this._add('M', x, y);\n  };\n\n  SVGPathRebuilder.prototype.lineTo = function (x, y) {\n    this._add('L', x, y);\n  };\n\n  SVGPathRebuilder.prototype.bezierCurveTo = function (x, y, x2, y2, x3, y3) {\n    this._add('C', x, y, x2, y2, x3, y3);\n  };\n\n  SVGPathRebuilder.prototype.quadraticCurveTo = function (x, y, x2, y2) {\n    this._add('Q', x, y, x2, y2);\n  };\n\n  SVGPathRebuilder.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n    this.ellipse(cx, cy, r, r, 0, startAngle, endAngle, anticlockwise);\n  };\n\n  SVGPathRebuilder.prototype.ellipse = function (cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise) {\n    var firstCmd = this._d.length === 0;\n    var dTheta = endAngle - startAngle;\n    var clockwise = !anticlockwise;\n    var dThetaPositive = Math.abs(dTheta);\n    var isCircle = isAroundZero(dThetaPositive - PI2) || (clockwise ? dTheta >= PI2 : -dTheta >= PI2);\n    var unifiedTheta = dTheta > 0 ? dTheta % PI2 : dTheta % PI2 + PI2;\n    var large = false;\n\n    if (isCircle) {\n      large = true;\n    } else if (isAroundZero(dThetaPositive)) {\n      large = false;\n    } else {\n      large = unifiedTheta >= PI === !!clockwise;\n    }\n\n    var x0 = round4(cx + rx * mathCos(startAngle));\n    var y0 = round4(cy + ry * mathSin(startAngle));\n\n    if (isCircle) {\n      if (clockwise) {\n        dTheta = PI2 - 1e-4;\n      } else {\n        dTheta = -PI2 + 1e-4;\n      }\n\n      large = true;\n\n      if (firstCmd) {\n        this._d.push('M', x0, y0);\n      }\n    }\n\n    var x = round4(cx + rx * mathCos(startAngle + dTheta));\n    var y = round4(cy + ry * mathSin(startAngle + dTheta));\n\n    if (isNaN(x0) || isNaN(y0) || isNaN(rx) || isNaN(ry) || isNaN(psi) || isNaN(degree) || isNaN(x) || isNaN(y)) {\n      return '';\n    }\n\n    this._d.push('A', round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);\n  };\n\n  SVGPathRebuilder.prototype.rect = function (x, y, w, h) {\n    this._add('M', x, y);\n\n    this._add('L', x + w, y);\n\n    this._add('L', x + w, y + h);\n\n    this._add('L', x, y + h);\n\n    this._add('L', x, y);\n  };\n\n  SVGPathRebuilder.prototype.closePath = function () {\n    if (this._d.length > 0) {\n      this._add('Z');\n    }\n  };\n\n  SVGPathRebuilder.prototype._add = function (cmd, a, b, c, d, e, f, g, h) {\n    this._d.push(cmd);\n\n    for (var i = 1; i < arguments.length; i++) {\n      var val = arguments[i];\n\n      if (isNaN(val)) {\n        this._invalid = true;\n        return;\n      }\n\n      this._d.push(round4(val));\n    }\n  };\n\n  SVGPathRebuilder.prototype.generateStr = function () {\n    this._str = this._invalid ? '' : this._d.join(' ');\n    this._d = [];\n  };\n\n  SVGPathRebuilder.prototype.getStr = function () {\n    return this._str;\n  };\n\n  return SVGPathRebuilder;\n}();\n\nvar svgPath = {\n  brush: function brush(el) {\n    var style = el.style;\n    var svgEl = el.__svgEl;\n\n    if (!svgEl) {\n      svgEl = createElement('path');\n      el.__svgEl = svgEl;\n    }\n\n    if (!el.path) {\n      el.createPathProxy();\n    }\n\n    var path = el.path;\n\n    if (el.shapeChanged()) {\n      path.beginPath();\n      el.buildPath(path, el.shape);\n      el.pathUpdated();\n    }\n\n    var pathVersion = path.getVersion();\n    var elExt = el;\n    var svgPathBuilder = elExt.__svgPathBuilder;\n\n    if (elExt.__svgPathVersion !== pathVersion || !svgPathBuilder || el.style.strokePercent < 1) {\n      if (!svgPathBuilder) {\n        svgPathBuilder = elExt.__svgPathBuilder = new SVGPathRebuilder();\n      }\n\n      svgPathBuilder.reset();\n      path.rebuildPath(svgPathBuilder, el.style.strokePercent);\n      svgPathBuilder.generateStr();\n      elExt.__svgPathVersion = pathVersion;\n    }\n\n    attr(svgEl, 'd', svgPathBuilder.getStr());\n    bindStyle(svgEl, style, el);\n    setTransform(svgEl, el.transform);\n  }\n};\nexport { svgPath as path };\nvar svgImage = {\n  brush: function brush(el) {\n    var style = el.style;\n    var image = style.image;\n\n    if (image instanceof HTMLImageElement) {\n      image = image.src;\n    } else if (image instanceof HTMLCanvasElement) {\n      image = image.toDataURL();\n    }\n\n    if (!image) {\n      return;\n    }\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var dw = style.width;\n    var dh = style.height;\n    var svgEl = el.__svgEl;\n\n    if (!svgEl) {\n      svgEl = createElement('image');\n      el.__svgEl = svgEl;\n    }\n\n    if (image !== el.__imageSrc) {\n      attrXLink(svgEl, 'href', image);\n      el.__imageSrc = image;\n    }\n\n    attr(svgEl, 'width', dw + '');\n    attr(svgEl, 'height', dh + '');\n    attr(svgEl, 'x', x + '');\n    attr(svgEl, 'y', y + '');\n    bindStyle(svgEl, style, el);\n    setTransform(svgEl, el.transform);\n  }\n};\nexport { svgImage as image };\nvar TEXT_ALIGN_TO_ANCHOR = {\n  left: 'start',\n  right: 'end',\n  center: 'middle',\n  middle: 'middle'\n};\n\nfunction adjustTextY(y, lineHeight, textBaseline) {\n  if (textBaseline === 'top') {\n    y += lineHeight / 2;\n  } else if (textBaseline === 'bottom') {\n    y -= lineHeight / 2;\n  }\n\n  return y;\n}\n\nvar svgText = {\n  brush: function brush(el) {\n    var style = el.style;\n    var text = style.text;\n    text != null && (text += '');\n\n    if (!text || isNaN(style.x) || isNaN(style.y)) {\n      return;\n    }\n\n    var textSvgEl = el.__svgEl;\n\n    if (!textSvgEl) {\n      textSvgEl = createElement('text');\n      attrXML(textSvgEl, 'xml:space', 'preserve');\n      el.__svgEl = textSvgEl;\n    }\n\n    var font = style.font || DEFAULT_FONT;\n    var textSvgElStyle = textSvgEl.style;\n    textSvgElStyle.font = font;\n    textSvgEl.textContent = text;\n    bindStyle(textSvgEl, style, el);\n    setTransform(textSvgEl, el.transform);\n    var x = style.x || 0;\n    var y = adjustTextY(style.y || 0, getLineHeight(font), style.textBaseline);\n    var textAlign = TEXT_ALIGN_TO_ANCHOR[style.textAlign] || style.textAlign;\n    attr(textSvgEl, 'dominant-baseline', 'central');\n    attr(textSvgEl, 'text-anchor', textAlign);\n    attr(textSvgEl, 'x', x + '');\n    attr(textSvgEl, 'y', y + '');\n  }\n};\nexport { svgText as text };","map":null,"metadata":{},"sourceType":"module"}