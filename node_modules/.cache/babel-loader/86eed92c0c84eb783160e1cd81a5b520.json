{"ast":null,"code":"import Group from '../graphic/Group';\nimport ZRImage from '../graphic/Image';\nimport Circle from '../graphic/shape/Circle';\nimport Rect from '../graphic/shape/Rect';\nimport Ellipse from '../graphic/shape/Ellipse';\nimport Line from '../graphic/shape/Line';\nimport Path from '../graphic/Path';\nimport Polygon from '../graphic/shape/Polygon';\nimport Polyline from '../graphic/shape/Polyline';\nimport * as matrix from '../core/matrix';\nimport { createFromString } from './path';\nimport { extend, defaults, trim, each, map } from '../core/util';\nimport LinearGradient from '../graphic/LinearGradient';\nimport TSpan from '../graphic/TSpan';\nimport { parseXML } from './parseXML';\nvar DILIMITER_REG = /[\\s,]+/;\nvar nodeParsers;\n\nvar SVGParser = function () {\n  function SVGParser() {\n    this._defs = {};\n    this._root = null;\n    this._isDefine = false;\n    this._isText = false;\n  }\n\n  SVGParser.prototype.parse = function (xml, opt) {\n    opt = opt || {};\n    var svg = parseXML(xml);\n\n    if (!svg) {\n      throw new Error('Illegal svg');\n    }\n\n    var root = new Group();\n    this._root = root;\n    var viewBox = svg.getAttribute('viewBox') || '';\n    var width = parseFloat(svg.getAttribute('width') || opt.width);\n    var height = parseFloat(svg.getAttribute('height') || opt.height);\n    isNaN(width) && (width = null);\n    isNaN(height) && (height = null);\n    parseAttributes(svg, root, null, true);\n    var child = svg.firstChild;\n\n    while (child) {\n      this._parseNode(child, root);\n\n      child = child.nextSibling;\n    }\n\n    var viewBoxRect;\n    var viewBoxTransform;\n\n    if (viewBox) {\n      var viewBoxArr = trim(viewBox).split(DILIMITER_REG);\n\n      if (viewBoxArr.length >= 4) {\n        viewBoxRect = {\n          x: parseFloat(viewBoxArr[0] || 0),\n          y: parseFloat(viewBoxArr[1] || 0),\n          width: parseFloat(viewBoxArr[2]),\n          height: parseFloat(viewBoxArr[3])\n        };\n      }\n    }\n\n    if (viewBoxRect && width != null && height != null) {\n      viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n\n      if (!opt.ignoreViewBox) {\n        var elRoot = root;\n        root = new Group();\n        root.add(elRoot);\n        elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;\n        elRoot.x = viewBoxTransform.x;\n        elRoot.y = viewBoxTransform.y;\n      }\n    }\n\n    if (!opt.ignoreRootClip && width != null && height != null) {\n      root.setClipPath(new Rect({\n        shape: {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        }\n      }));\n    }\n\n    return {\n      root: root,\n      width: width,\n      height: height,\n      viewBoxRect: viewBoxRect,\n      viewBoxTransform: viewBoxTransform\n    };\n  };\n\n  SVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n    var nodeName = xmlNode.nodeName.toLowerCase();\n\n    if (nodeName === 'defs') {\n      this._isDefine = true;\n    } else if (nodeName === 'text') {\n      this._isText = true;\n    }\n\n    var el;\n\n    if (this._isDefine) {\n      var parser = defineParsers[nodeName];\n\n      if (parser) {\n        var def = parser.call(this, xmlNode);\n        var id = xmlNode.getAttribute('id');\n\n        if (id) {\n          this._defs[id] = def;\n        }\n      }\n    } else {\n      var parser = nodeParsers[nodeName];\n\n      if (parser) {\n        el = parser.call(this, xmlNode, parentGroup);\n        parentGroup.add(el);\n      }\n    }\n\n    if (el) {\n      var child = xmlNode.firstChild;\n\n      while (child) {\n        if (child.nodeType === 1) {\n          this._parseNode(child, el);\n        }\n\n        if (child.nodeType === 3 && this._isText) {\n          this._parseText(child, el);\n        }\n\n        child = child.nextSibling;\n      }\n    }\n\n    if (nodeName === 'defs') {\n      this._isDefine = false;\n    } else if (nodeName === 'text') {\n      this._isText = false;\n    }\n  };\n\n  SVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n    if (xmlNode.nodeType === 1) {\n      var dx = xmlNode.getAttribute('dx') || 0;\n      var dy = xmlNode.getAttribute('dy') || 0;\n      this._textX += parseFloat(dx);\n      this._textY += parseFloat(dy);\n    }\n\n    var text = new TSpan({\n      style: {\n        text: xmlNode.textContent\n      },\n      x: this._textX || 0,\n      y: this._textY || 0\n    });\n    inheritStyle(parentGroup, text);\n    parseAttributes(xmlNode, text, this._defs);\n    var textStyle = text.style;\n    var fontSize = textStyle.fontSize;\n\n    if (fontSize && fontSize < 9) {\n      textStyle.fontSize = 9;\n      text.scaleX *= fontSize / 9;\n      text.scaleY *= fontSize / 9;\n    }\n\n    var font = (textStyle.fontSize || textStyle.fontFamily) && [textStyle.fontStyle, textStyle.fontWeight, (textStyle.fontSize || 12) + 'px', textStyle.fontFamily || 'sans-serif'].join(' ');\n    textStyle.font = font;\n    var rect = text.getBoundingRect();\n    this._textX += rect.width;\n    parentGroup.add(text);\n    return text;\n  };\n\n  SVGParser.internalField = function () {\n    nodeParsers = {\n      'g': function g(xmlNode, parentGroup) {\n        var g = new Group();\n        inheritStyle(parentGroup, g);\n        parseAttributes(xmlNode, g, this._defs);\n        return g;\n      },\n      'rect': function rect(xmlNode, parentGroup) {\n        var rect = new Rect();\n        inheritStyle(parentGroup, rect);\n        parseAttributes(xmlNode, rect, this._defs);\n        rect.setShape({\n          x: parseFloat(xmlNode.getAttribute('x') || '0'),\n          y: parseFloat(xmlNode.getAttribute('y') || '0'),\n          width: parseFloat(xmlNode.getAttribute('width') || '0'),\n          height: parseFloat(xmlNode.getAttribute('height') || '0')\n        });\n        return rect;\n      },\n      'circle': function circle(xmlNode, parentGroup) {\n        var circle = new Circle();\n        inheritStyle(parentGroup, circle);\n        parseAttributes(xmlNode, circle, this._defs);\n        circle.setShape({\n          cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n          cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n          r: parseFloat(xmlNode.getAttribute('r') || '0')\n        });\n        return circle;\n      },\n      'line': function line(xmlNode, parentGroup) {\n        var line = new Line();\n        inheritStyle(parentGroup, line);\n        parseAttributes(xmlNode, line, this._defs);\n        line.setShape({\n          x1: parseFloat(xmlNode.getAttribute('x1') || '0'),\n          y1: parseFloat(xmlNode.getAttribute('y1') || '0'),\n          x2: parseFloat(xmlNode.getAttribute('x2') || '0'),\n          y2: parseFloat(xmlNode.getAttribute('y2') || '0')\n        });\n        return line;\n      },\n      'ellipse': function ellipse(xmlNode, parentGroup) {\n        var ellipse = new Ellipse();\n        inheritStyle(parentGroup, ellipse);\n        parseAttributes(xmlNode, ellipse, this._defs);\n        ellipse.setShape({\n          cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n          cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n          rx: parseFloat(xmlNode.getAttribute('rx') || '0'),\n          ry: parseFloat(xmlNode.getAttribute('ry') || '0')\n        });\n        return ellipse;\n      },\n      'polygon': function polygon(xmlNode, parentGroup) {\n        var pointsStr = xmlNode.getAttribute('points');\n        var pointsArr;\n\n        if (pointsStr) {\n          pointsArr = parsePoints(pointsStr);\n        }\n\n        var polygon = new Polygon({\n          shape: {\n            points: pointsArr || []\n          }\n        });\n        inheritStyle(parentGroup, polygon);\n        parseAttributes(xmlNode, polygon, this._defs);\n        return polygon;\n      },\n      'polyline': function polyline(xmlNode, parentGroup) {\n        var path = new Path();\n        inheritStyle(parentGroup, path);\n        parseAttributes(xmlNode, path, this._defs);\n        var pointsStr = xmlNode.getAttribute('points');\n        var pointsArr;\n\n        if (pointsStr) {\n          pointsArr = parsePoints(pointsStr);\n        }\n\n        var polyline = new Polyline({\n          shape: {\n            points: pointsArr || []\n          }\n        });\n        return polyline;\n      },\n      'image': function image(xmlNode, parentGroup) {\n        var img = new ZRImage();\n        inheritStyle(parentGroup, img);\n        parseAttributes(xmlNode, img, this._defs);\n        img.setStyle({\n          image: xmlNode.getAttribute('xlink:href'),\n          x: +xmlNode.getAttribute('x'),\n          y: +xmlNode.getAttribute('y'),\n          width: +xmlNode.getAttribute('width'),\n          height: +xmlNode.getAttribute('height')\n        });\n        return img;\n      },\n      'text': function text(xmlNode, parentGroup) {\n        var x = xmlNode.getAttribute('x') || '0';\n        var y = xmlNode.getAttribute('y') || '0';\n        var dx = xmlNode.getAttribute('dx') || '0';\n        var dy = xmlNode.getAttribute('dy') || '0';\n        this._textX = parseFloat(x) + parseFloat(dx);\n        this._textY = parseFloat(y) + parseFloat(dy);\n        var g = new Group();\n        inheritStyle(parentGroup, g);\n        parseAttributes(xmlNode, g, this._defs);\n        return g;\n      },\n      'tspan': function tspan(xmlNode, parentGroup) {\n        var x = xmlNode.getAttribute('x');\n        var y = xmlNode.getAttribute('y');\n\n        if (x != null) {\n          this._textX = parseFloat(x);\n        }\n\n        if (y != null) {\n          this._textY = parseFloat(y);\n        }\n\n        var dx = xmlNode.getAttribute('dx') || 0;\n        var dy = xmlNode.getAttribute('dy') || 0;\n        var g = new Group();\n        inheritStyle(parentGroup, g);\n        parseAttributes(xmlNode, g, this._defs);\n        this._textX += dx;\n        this._textY += dy;\n        return g;\n      },\n      'path': function path(xmlNode, parentGroup) {\n        var d = xmlNode.getAttribute('d') || '';\n        var path = createFromString(d);\n        inheritStyle(parentGroup, path);\n        parseAttributes(xmlNode, path, this._defs);\n        return path;\n      }\n    };\n  }();\n\n  return SVGParser;\n}();\n\nvar defineParsers = {\n  'lineargradient': function lineargradient(xmlNode) {\n    var x1 = parseInt(xmlNode.getAttribute('x1') || '0', 10);\n    var y1 = parseInt(xmlNode.getAttribute('y1') || '0', 10);\n    var x2 = parseInt(xmlNode.getAttribute('x2') || '10', 10);\n    var y2 = parseInt(xmlNode.getAttribute('y2') || '0', 10);\n    var gradient = new LinearGradient(x1, y1, x2, y2);\n\n    _parseGradientColorStops(xmlNode, gradient);\n\n    return gradient;\n  }\n};\n\nfunction _parseGradientColorStops(xmlNode, gradient) {\n  var stop = xmlNode.firstChild;\n\n  while (stop) {\n    if (stop.nodeType === 1) {\n      var offsetStr = stop.getAttribute('offset');\n      var offset = void 0;\n\n      if (offsetStr.indexOf('%') > 0) {\n        offset = parseInt(offsetStr, 10) / 100;\n      } else if (offsetStr) {\n        offset = parseFloat(offsetStr);\n      } else {\n        offset = 0;\n      }\n\n      var stopColor = stop.getAttribute('stop-color') || '#000000';\n      gradient.colorStops.push({\n        offset: offset,\n        color: stopColor\n      });\n    }\n\n    stop = stop.nextSibling;\n  }\n}\n\nfunction inheritStyle(parent, child) {\n  if (parent && parent.__inheritedStyle) {\n    if (!child.__inheritedStyle) {\n      child.__inheritedStyle = {};\n    }\n\n    defaults(child.__inheritedStyle, parent.__inheritedStyle);\n  }\n}\n\nfunction parsePoints(pointsString) {\n  var list = trim(pointsString).split(DILIMITER_REG);\n  var points = [];\n\n  for (var i = 0; i < list.length; i += 2) {\n    var x = parseFloat(list[i]);\n    var y = parseFloat(list[i + 1]);\n    points.push([x, y]);\n  }\n\n  return points;\n}\n\nvar attributesMap = {\n  'fill': 'fill',\n  'stroke': 'stroke',\n  'stroke-width': 'lineWidth',\n  'opacity': 'opacity',\n  'fill-opacity': 'fillOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  'stroke-dasharray': 'lineDash',\n  'stroke-dashoffset': 'lineDashOffset',\n  'stroke-linecap': 'lineCap',\n  'stroke-linejoin': 'lineJoin',\n  'stroke-miterlimit': 'miterLimit',\n  'font-family': 'fontFamily',\n  'font-size': 'fontSize',\n  'font-style': 'fontStyle',\n  'font-weight': 'fontWeight',\n  'text-align': 'textAlign',\n  'alignment-baseline': 'textBaseline'\n};\n\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n  var disp = el;\n  var zrStyle = disp.__inheritedStyle || {};\n\n  if (xmlNode.nodeType === 1) {\n    parseTransformAttribute(xmlNode, el);\n    extend(zrStyle, parseStyleAttribute(xmlNode));\n\n    if (!onlyInlineStyle) {\n      for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName)) {\n          var attrValue = xmlNode.getAttribute(svgAttrName);\n\n          if (attrValue != null) {\n            zrStyle[attributesMap[svgAttrName]] = attrValue;\n          }\n        }\n      }\n    }\n  }\n\n  disp.style = disp.style || {};\n  zrStyle.fill != null && (disp.style.fill = getPaint(zrStyle.fill, defs));\n  zrStyle.stroke != null && (disp.style.stroke = getPaint(zrStyle.stroke, defs));\n  each(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {\n    zrStyle[propName] != null && (disp.style[propName] = parseFloat(zrStyle[propName]));\n  });\n\n  if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n    zrStyle.textBaseline = 'alphabetic';\n  }\n\n  if (zrStyle.textBaseline === 'alphabetic') {\n    zrStyle.textBaseline = 'bottom';\n  }\n\n  if (zrStyle.textAlign === 'start') {\n    zrStyle.textAlign = 'left';\n  }\n\n  if (zrStyle.textAlign === 'end') {\n    zrStyle.textAlign = 'right';\n  }\n\n  each(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {\n    zrStyle[propName] != null && (disp.style[propName] = zrStyle[propName]);\n  });\n\n  if (zrStyle.lineDash) {\n    disp.style.lineDash = map(trim(zrStyle.lineDash).split(DILIMITER_REG), function (str) {\n      return parseFloat(str);\n    });\n  }\n\n  disp.__inheritedStyle = zrStyle;\n}\n\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\n\nfunction getPaint(str, defs) {\n  var urlMatch = defs && str && str.match(urlRegex);\n\n  if (urlMatch) {\n    var url = trim(urlMatch[1]);\n    var def = defs[url];\n    return def;\n  }\n\n  return str;\n}\n\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\n\nfunction parseTransformAttribute(xmlNode, node) {\n  var transform = xmlNode.getAttribute('transform');\n\n  if (transform) {\n    transform = transform.replace(/,/g, ' ');\n    var transformOps_1 = [];\n    var m = null;\n    transform.replace(transformRegex, function (str, type, value) {\n      transformOps_1.push(type, value);\n      return '';\n    });\n\n    for (var i = transformOps_1.length - 1; i > 0; i -= 2) {\n      var value = transformOps_1[i];\n      var type = transformOps_1[i - 1];\n      var valueArr = void 0;\n      m = m || matrix.create();\n\n      switch (type) {\n        case 'translate':\n          valueArr = trim(value).split(DILIMITER_REG);\n          matrix.translate(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || '0')]);\n          break;\n\n        case 'scale':\n          valueArr = trim(value).split(DILIMITER_REG);\n          matrix.scale(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);\n          break;\n\n        case 'rotate':\n          valueArr = trim(value).split(DILIMITER_REG);\n          matrix.rotate(m, m, parseFloat(valueArr[0]));\n          break;\n\n        case 'skew':\n          valueArr = trim(value).split(DILIMITER_REG);\n          console.warn('Skew transform is not supported yet');\n          break;\n\n        case 'matrix':\n          valueArr = trim(value).split(DILIMITER_REG);\n          m[0] = parseFloat(valueArr[0]);\n          m[1] = parseFloat(valueArr[1]);\n          m[2] = parseFloat(valueArr[2]);\n          m[3] = parseFloat(valueArr[3]);\n          m[4] = parseFloat(valueArr[4]);\n          m[5] = parseFloat(valueArr[5]);\n          break;\n      }\n    }\n\n    node.setLocalTransform(m);\n  }\n}\n\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\n\nfunction parseStyleAttribute(xmlNode) {\n  var style = xmlNode.getAttribute('style');\n  var result = {};\n\n  if (!style) {\n    return result;\n  }\n\n  var styleList = {};\n  styleRegex.lastIndex = 0;\n  var styleRegResult;\n\n  while ((styleRegResult = styleRegex.exec(style)) != null) {\n    styleList[styleRegResult[1]] = styleRegResult[2];\n  }\n\n  for (var svgAttrName in attributesMap) {\n    if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n      result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n    }\n  }\n\n  return result;\n}\n\nexport function makeViewBoxTransform(viewBoxRect, width, height) {\n  var scaleX = width / viewBoxRect.width;\n  var scaleY = height / viewBoxRect.height;\n  var scale = Math.min(scaleX, scaleY);\n  return {\n    scale: scale,\n    x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2,\n    y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2\n  };\n}\nexport function parseSVG(xml, opt) {\n  var parser = new SVGParser();\n  return parser.parse(xml, opt);\n}\nexport { parseXML };","map":null,"metadata":{},"sourceType":"module"}