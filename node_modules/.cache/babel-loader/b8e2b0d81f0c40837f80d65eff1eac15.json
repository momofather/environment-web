{"ast":null,"code":"import PathProxy from '../core/PathProxy';\nimport { cubicSubdivide } from '../core/curve';\nimport { defaults, assert, noop, clone } from '../core/util';\nimport { lerp } from '../core/vector';\nimport Rect from '../graphic/shape/Rect';\nimport Sector from '../graphic/shape/Sector';\nvar CMD = PathProxy.CMD;\nvar PI2 = Math.PI * 2;\nvar PROP_XY = ['x', 'y'];\nvar PROP_WH = ['width', 'height'];\nvar tmpArr = [];\n\nfunction aroundEqual(a, b) {\n  return Math.abs(a - b) < 1e-5;\n}\n\nexport function pathToBezierCurves(path) {\n  var data = path.data;\n  var len = path.len();\n  var bezierArray = [];\n  var currentSubpath;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n\n  function createNewSubpath(x, y) {\n    if (currentSubpath && currentSubpath.length > 2) {\n      bezierArray.push(currentSubpath);\n    }\n\n    currentSubpath = [x, y];\n  }\n\n  function addLine(x0, y0, x1, y1) {\n    if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n      currentSubpath.push(x0, y0, x1, y1, x1, y1);\n    }\n  }\n\n  function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n    var delta = Math.abs(endAngle - startAngle);\n    var len = Math.tan(delta / 4) * 4 / 3;\n    var dir = endAngle < startAngle ? -1 : 1;\n    var c1 = Math.cos(startAngle);\n    var s1 = Math.sin(startAngle);\n    var c2 = Math.cos(endAngle);\n    var s2 = Math.sin(endAngle);\n    var x1 = c1 * rx + cx;\n    var y1 = s1 * ry + cy;\n    var x4 = c2 * rx + cx;\n    var y4 = s2 * ry + cy;\n    var hx = rx * len * dir;\n    var hy = ry * len * dir;\n    currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n  }\n\n  var x1;\n  var y1;\n  var x2;\n  var y2;\n\n  for (var i = 0; i < len;) {\n    var cmd = data[i++];\n    var isFirst = i === 1;\n\n    if (isFirst) {\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n\n      if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {\n        currentSubpath = [x0, y0];\n      }\n    }\n\n    switch (cmd) {\n      case CMD.M:\n        xi = x0 = data[i++];\n        yi = y0 = data[i++];\n        createNewSubpath(x0, y0);\n        break;\n\n      case CMD.L:\n        x1 = data[i++];\n        y1 = data[i++];\n        addLine(xi, yi, x1, y1);\n        xi = x1;\n        yi = y1;\n        break;\n\n      case CMD.C:\n        currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n        break;\n\n      case CMD.Q:\n        x1 = data[i++];\n        y1 = data[i++];\n        x2 = data[i++];\n        y2 = data[i++];\n        currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n        xi = x2;\n        yi = y2;\n        break;\n\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var startAngle = data[i++];\n        var endAngle = data[i++] + startAngle;\n        i += 1;\n        var anticlockwise = !data[i++];\n        x1 = Math.cos(startAngle) * rx + cx;\n        y1 = Math.sin(startAngle) * ry + cy;\n\n        if (isFirst) {\n          x0 = x1;\n          y0 = y1;\n          createNewSubpath(x0, y0);\n        } else {\n          addLine(xi, yi, x1, y1);\n        }\n\n        xi = Math.cos(endAngle) * rx + cx;\n        yi = Math.sin(endAngle) * ry + cy;\n        var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n\n        for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n          var nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);\n          addArc(angle, nextAngle, cx, cy, rx, ry);\n        }\n\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        x1 = x0 + data[i++];\n        y1 = y0 + data[i++];\n        createNewSubpath(x1, y0);\n        addLine(x1, y0, x1, y1);\n        addLine(x1, y1, x0, y1);\n        addLine(x0, y1, x0, y0);\n        addLine(x0, y0, x1, y0);\n        break;\n\n      case CMD.Z:\n        currentSubpath && addLine(xi, yi, x0, y0);\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n\n  if (currentSubpath && currentSubpath.length > 2) {\n    bezierArray.push(currentSubpath);\n  }\n\n  return bezierArray;\n}\n\nfunction alignSubpath(subpath1, subpath2) {\n  var len1 = subpath1.length;\n  var len2 = subpath2.length;\n\n  if (len1 === len2) {\n    return [subpath1, subpath2];\n  }\n\n  var shorterPath = len1 < len2 ? subpath1 : subpath2;\n  var shorterLen = Math.min(len1, len2);\n  var diff = Math.abs(len2 - len1) / 6;\n  var shorterBezierCount = (shorterLen - 2) / 6;\n  var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n  var newSubpath = [shorterPath[0], shorterPath[1]];\n  var remained = diff;\n  var tmpSegX = [];\n  var tmpSegY = [];\n\n  for (var i = 2; i < shorterLen;) {\n    var x0 = shorterPath[i - 2];\n    var y0 = shorterPath[i - 1];\n    var x1 = shorterPath[i++];\n    var y1 = shorterPath[i++];\n    var x2 = shorterPath[i++];\n    var y2 = shorterPath[i++];\n    var x3 = shorterPath[i++];\n    var y3 = shorterPath[i++];\n\n    if (remained <= 0) {\n      newSubpath.push(x1, y1, x2, y2, x3, y3);\n      continue;\n    }\n\n    var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n\n    for (var k = 1; k <= actualSubDivCount; k++) {\n      var p = k / actualSubDivCount;\n      cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n      cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n      x0 = tmpSegX[3];\n      y0 = tmpSegY[3];\n      newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n      x1 = tmpSegX[5];\n      y1 = tmpSegY[5];\n      x2 = tmpSegX[6];\n      y2 = tmpSegY[6];\n    }\n\n    remained -= actualSubDivCount - 1;\n  }\n\n  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\n\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n  var len = lastSubpathSubpath.length;\n  var lastX = lastSubpathSubpath[len - 2];\n  var lastY = lastSubpathSubpath[len - 1];\n  var newSubpath = [];\n\n  for (var i = 0; i < otherSubpath.length;) {\n    newSubpath[i++] = lastX;\n    newSubpath[i++] = lastY;\n  }\n\n  return newSubpath;\n}\n\nexport function alignBezierCurves(array1, array2) {\n  var _a;\n\n  var lastSubpath1;\n  var lastSubpath2;\n  var newArray1 = [];\n  var newArray2 = [];\n\n  for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n    var subpath1 = array1[i];\n    var subpath2 = array2[i];\n    var newSubpath1 = void 0;\n    var newSubpath2 = void 0;\n\n    if (!subpath1) {\n      newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n      newSubpath2 = subpath2;\n    } else if (!subpath2) {\n      newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n      newSubpath1 = subpath1;\n    } else {\n      _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n      lastSubpath1 = newSubpath1;\n      lastSubpath2 = newSubpath2;\n    }\n\n    newArray1.push(newSubpath1);\n    newArray2.push(newSubpath2);\n  }\n\n  return [newArray1, newArray2];\n}\nexport function centroid(array) {\n  var signedArea = 0;\n  var cx = 0;\n  var cy = 0;\n  var len = array.length;\n\n  for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n    var x0 = array[j];\n    var y0 = array[j + 1];\n    var x1 = array[i];\n    var y1 = array[i + 1];\n    var a = x0 * y1 - x1 * y0;\n    signedArea += a;\n    cx += (x0 + x1) * a;\n    cy += (y0 + y1) * a;\n  }\n\n  if (signedArea === 0) {\n    return [array[0] || 0, array[1] || 0];\n  }\n\n  return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\n\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n  var bezierCount = (fromSubBeziers.length - 2) / 6;\n  var bestScore = Infinity;\n  var bestOffset = 0;\n  var len = fromSubBeziers.length;\n  var len2 = len - 2;\n\n  for (var offset = 0; offset < bezierCount; offset++) {\n    var cursorOffset = offset * 6;\n    var score = 0;\n\n    for (var k = 0; k < len; k += 2) {\n      var idx = k === 0 ? cursorOffset : (cursorOffset + k - 2) % len2 + 2;\n      var x0 = fromSubBeziers[idx] - fromCp[0];\n      var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n      var x1 = toSubBeziers[k] - toCp[0];\n      var y1 = toSubBeziers[k + 1] - toCp[1];\n      var dx = x1 - x0;\n      var dy = y1 - y0;\n      score += dx * dx + dy * dy;\n    }\n\n    if (score < bestScore) {\n      bestScore = score;\n      bestOffset = offset;\n    }\n  }\n\n  return bestOffset;\n}\n\nfunction reverse(array) {\n  var newArr = [];\n  var len = array.length;\n\n  for (var i = 0; i < len; i += 2) {\n    newArr[i] = array[len - i - 2];\n    newArr[i + 1] = array[len - i - 1];\n  }\n\n  return newArr;\n}\n\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n  var result = [];\n  var fromNeedsReverse;\n\n  for (var i = 0; i < fromArr.length; i++) {\n    var fromSubpathBezier = fromArr[i];\n    var toSubpathBezier = toArr[i];\n    var fromCp = centroid(fromSubpathBezier);\n    var toCp = centroid(toSubpathBezier);\n\n    if (fromNeedsReverse == null) {\n      fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n    }\n\n    var newFromSubpathBezier = [];\n    var newToSubpathBezier = [];\n    var bestAngle = 0;\n    var bestScore = Infinity;\n    var tmpArr_1 = [];\n    var len = fromSubpathBezier.length;\n\n    if (fromNeedsReverse) {\n      fromSubpathBezier = reverse(fromSubpathBezier);\n    }\n\n    var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n    var len2 = len - 2;\n\n    for (var k = 0; k < len2; k += 2) {\n      var idx = (offset + k) % len2 + 2;\n      newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n      newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n    }\n\n    newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n    newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n\n    if (searchAngleIteration > 0) {\n      var step = searchAngleRange / searchAngleIteration;\n\n      for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n        var sa = Math.sin(angle);\n        var ca = Math.cos(angle);\n        var score = 0;\n\n        for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n          var x0 = newFromSubpathBezier[k];\n          var y0 = newFromSubpathBezier[k + 1];\n          var x1 = toSubpathBezier[k] - toCp[0];\n          var y1 = toSubpathBezier[k + 1] - toCp[1];\n          var newX1 = x1 * ca - y1 * sa;\n          var newY1 = x1 * sa + y1 * ca;\n          tmpArr_1[k] = newX1;\n          tmpArr_1[k + 1] = newY1;\n          var dx = newX1 - x0;\n          var dy = newY1 - y0;\n          score += dx * dx + dy * dy;\n        }\n\n        if (score < bestScore) {\n          bestScore = score;\n          bestAngle = angle;\n\n          for (var m = 0; m < tmpArr_1.length; m++) {\n            newToSubpathBezier[m] = tmpArr_1[m];\n          }\n        }\n      }\n    } else {\n      for (var i_1 = 0; i_1 < len; i_1 += 2) {\n        newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n        newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n      }\n    }\n\n    result.push({\n      from: newFromSubpathBezier,\n      to: newToSubpathBezier,\n      fromCp: fromCp,\n      toCp: toCp,\n      rotation: -bestAngle\n    });\n  }\n\n  return result;\n}\n\nexport function morphPath(fromPath, toPath, animationOpts) {\n  var fromPathProxy;\n  var toPathProxy;\n\n  if (!fromPath || !toPath) {\n    return toPath;\n  }\n\n  !fromPath.path && fromPath.createPathProxy();\n  fromPathProxy = fromPath.path;\n  fromPathProxy.beginPath();\n  fromPath.buildPath(fromPathProxy, fromPath.shape);\n  !toPath.path && toPath.createPathProxy();\n  toPathProxy = toPath.path;\n  toPathProxy === fromPathProxy && (toPathProxy = new PathProxy(false));\n  toPathProxy.beginPath();\n\n  if (isIndividualMorphingPath(toPath)) {\n    toPath.__oldBuildPath(toPathProxy, toPath.shape);\n  } else {\n    toPath.buildPath(toPathProxy, toPath.shape);\n  }\n\n  var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)),\n      fromBezierCurves = _a[0],\n      toBezierCurves = _a[1];\n\n  var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n  becomeIndividualMorphingPath(toPath, morphingData, 0);\n  var oldDone = animationOpts && animationOpts.done;\n  var oldAborted = animationOpts && animationOpts.aborted;\n  var oldDuring = animationOpts && animationOpts.during;\n  toPath.animateTo({\n    __morphT: 1\n  }, defaults({\n    during: function during(p) {\n      toPath.dirtyShape();\n      oldDuring && oldDuring(p);\n    },\n    done: function done() {\n      restoreIndividualMorphingPath(toPath);\n      toPath.createPathProxy();\n      toPath.dirtyShape();\n      oldDone && oldDone();\n    },\n    aborted: function aborted() {\n      oldAborted && oldAborted();\n    }\n  }, animationOpts));\n  return toPath;\n}\n\nfunction morphingPathBuildPath(path) {\n  var morphingData = this.__morphingData;\n  var t = this.__morphT;\n  var onet = 1 - t;\n  var newCp = [];\n\n  for (var i = 0; i < morphingData.length; i++) {\n    var item = morphingData[i];\n    var from = item.from;\n    var to = item.to;\n    var angle = item.rotation * t;\n    var fromCp = item.fromCp;\n    var toCp = item.toCp;\n    var sa = Math.sin(angle);\n    var ca = Math.cos(angle);\n    lerp(newCp, fromCp, toCp, t);\n\n    for (var m = 0; m < from.length; m += 2) {\n      var x0 = from[m];\n      var y0 = from[m + 1];\n      var x1 = to[m];\n      var y1 = to[m + 1];\n      var x = x0 * onet + x1 * t;\n      var y = y0 * onet + y1 * t;\n      tmpArr[m] = x * ca - y * sa + newCp[0];\n      tmpArr[m + 1] = x * sa + y * ca + newCp[1];\n    }\n\n    for (var m = 0; m < from.length;) {\n      if (m === 0) {\n        path.moveTo(tmpArr[m++], tmpArr[m++]);\n      }\n\n      path.bezierCurveTo(tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++]);\n    }\n  }\n}\n\n;\n\nfunction becomeIndividualMorphingPath(path, morphingData, morphT) {\n  if (isIndividualMorphingPath(path)) {\n    updateIndividualMorphingPath(path, morphingData, morphT);\n    return;\n  }\n\n  var morphingPath = path;\n  morphingPath.__oldBuildPath = morphingPath.buildPath;\n  morphingPath.buildPath = morphingPathBuildPath;\n  updateIndividualMorphingPath(morphingPath, morphingData, morphT);\n}\n\nfunction updateIndividualMorphingPath(morphingPath, morphingData, morphT) {\n  morphingPath.__morphingData = morphingData;\n  morphingPath.__morphT = morphT;\n}\n\nfunction restoreIndividualMorphingPath(path) {\n  if (isIndividualMorphingPath(path)) {\n    path.buildPath = path.__oldBuildPath;\n    path.__oldBuildPath = path.__morphingData = null;\n  }\n}\n\nfunction isIndividualMorphingPath(path) {\n  return path.__oldBuildPath != null;\n}\n\nexport function isCombiningPath(path) {\n  return !!path.__combiningSubList;\n}\nexport function isInAnyMorphing(path) {\n  return isIndividualMorphingPath(path) || isCombiningPath(path);\n}\nexport function combine(fromPathList, toPath, animationOpts, copyPropsIfDivided) {\n  var fromIndividuals = [];\n  var separateCount = 0;\n\n  for (var i = 0; i < fromPathList.length; i++) {\n    var fromPath = fromPathList[i];\n\n    if (isCombiningPath(fromPath)) {\n      var fromCombiningSubList = fromPath.__combiningSubList;\n\n      for (var j = 0; j < fromCombiningSubList.length; j++) {\n        fromIndividuals.push(fromCombiningSubList[j]);\n      }\n\n      separateCount += fromCombiningSubList.length;\n    } else {\n      fromIndividuals.push(fromPath);\n      separateCount++;\n    }\n  }\n\n  if (!separateCount) {\n    return;\n  }\n\n  var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n  var toPathSplittedList = divideShape(toPath, separateCount, dividingMethod);\n  assert(toPathSplittedList.length === separateCount);\n  var oldDone = animationOpts && animationOpts.done;\n  var oldAborted = animationOpts && animationOpts.aborted;\n  var oldDuring = animationOpts && animationOpts.during;\n  var doneCount = 0;\n  var abortedCalled = false;\n  var morphAnimationOpts = defaults({\n    during: function during(p) {\n      oldDuring && oldDuring(p);\n    },\n    done: function done() {\n      doneCount++;\n\n      if (doneCount === toPathSplittedList.length) {\n        restoreCombiningPath(toPath);\n        oldDone && oldDone();\n      }\n    },\n    aborted: function aborted() {\n      if (!abortedCalled) {\n        abortedCalled = true;\n        oldAborted && oldAborted();\n      }\n    }\n  }, animationOpts);\n\n  for (var i = 0; i < separateCount; i++) {\n    var from = fromIndividuals[i];\n    var to = toPathSplittedList[i];\n    copyPropsIfDivided && copyPropsIfDivided(toPath, to, true);\n    morphPath(from, to, morphAnimationOpts);\n  }\n\n  becomeCombiningPath(toPath, toPathSplittedList);\n  return {\n    fromIndividuals: fromIndividuals,\n    toIndividuals: toPathSplittedList,\n    count: separateCount\n  };\n}\n\nfunction becomeCombiningPath(path, combiningSubList) {\n  if (isCombiningPath(path)) {\n    updateCombiningPathSubList(path, combiningSubList);\n    return;\n  }\n\n  var combiningPath = path;\n  updateCombiningPathSubList(combiningPath, combiningSubList);\n  combiningPath.__oldAddSelfToZr = path.addSelfToZr;\n  combiningPath.__oldRemoveSelfFromZr = path.removeSelfFromZr;\n  combiningPath.addSelfToZr = combiningAddSelfToZr;\n  combiningPath.removeSelfFromZr = combiningRemoveSelfFromZr;\n  combiningPath.__oldBuildPath = combiningPath.buildPath;\n  combiningPath.buildPath = noop;\n  combiningPath.childrenRef = combiningChildrenRef;\n}\n\nfunction restoreCombiningPath(path) {\n  if (!isCombiningPath(path)) {\n    return;\n  }\n\n  var combiningPath = path;\n  updateCombiningPathSubList(combiningPath, null);\n  combiningPath.addSelfToZr = combiningPath.__oldAddSelfToZr;\n  combiningPath.removeSelfFromZr = combiningPath.__oldRemoveSelfFromZr;\n  combiningPath.buildPath = combiningPath.__oldBuildPath;\n  combiningPath.childrenRef = combiningPath.__combiningSubList = combiningPath.__oldAddSelfToZr = combiningPath.__oldRemoveSelfFromZr = combiningPath.__oldBuildPath = null;\n}\n\nfunction updateCombiningPathSubList(combiningPath, combiningSubList) {\n  if (combiningPath.__combiningSubList !== combiningSubList) {\n    combiningPathSubListAddRemoveWithZr(combiningPath, 'removeSelfFromZr');\n    combiningPath.__combiningSubList = combiningSubList;\n\n    if (combiningSubList) {\n      for (var i = 0; i < combiningSubList.length; i++) {\n        combiningSubList[i].parent = combiningPath;\n      }\n    }\n\n    combiningPathSubListAddRemoveWithZr(combiningPath, 'addSelfToZr');\n  }\n}\n\nfunction combiningAddSelfToZr(zr) {\n  this.__oldAddSelfToZr(zr);\n\n  combiningPathSubListAddRemoveWithZr(this, 'addSelfToZr');\n}\n\nfunction combiningPathSubListAddRemoveWithZr(path, method) {\n  var combiningSubList = path.__combiningSubList;\n  var zr = path.__zr;\n\n  if (combiningSubList && zr) {\n    for (var i = 0; i < combiningSubList.length; i++) {\n      var child = combiningSubList[i];\n      child[method](zr);\n    }\n  }\n}\n\nfunction combiningRemoveSelfFromZr(zr) {\n  this.__oldRemoveSelfFromZr(zr);\n\n  var combiningSubList = this.__combiningSubList;\n\n  for (var i = 0; i < combiningSubList.length; i++) {\n    var child = combiningSubList[i];\n    child.removeSelfFromZr(zr);\n  }\n}\n\nfunction combiningChildrenRef() {\n  return this.__combiningSubList;\n}\n\nexport function separate(fromPath, toPathList, animationOpts, copyPropsIfDivided) {\n  var toPathListLen = toPathList.length;\n  var fromPathList;\n  var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n  var copyProps = false;\n\n  if (isCombiningPath(fromPath)) {\n    var fromCombiningSubList = fromPath.__combiningSubList;\n\n    if (fromCombiningSubList.length === toPathListLen) {\n      fromPathList = fromCombiningSubList;\n    } else {\n      fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n      copyProps = true;\n    }\n  } else {\n    fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n    copyProps = true;\n  }\n\n  assert(fromPathList.length === toPathListLen);\n\n  for (var i = 0; i < toPathListLen; i++) {\n    if (copyProps && copyPropsIfDivided) {\n      copyPropsIfDivided(fromPath, fromPathList[i], false);\n    }\n\n    morphPath(fromPathList[i], toPathList[i], animationOpts);\n  }\n\n  return {\n    fromIndividuals: fromPathList,\n    toIndividuals: toPathList,\n    count: toPathListLen\n  };\n}\n\nfunction divideShape(path, separateCount, dividingMethod) {\n  return dividingMethod === 'duplicate' ? duplicateShape(path, separateCount) : splitShape(path, separateCount);\n}\n\nfunction splitShape(path, separateCount) {\n  var resultPaths = [];\n\n  if (separateCount <= 0) {\n    return resultPaths;\n  }\n\n  if (separateCount === 1) {\n    return duplicateShape(path, separateCount);\n  }\n\n  if (path instanceof Rect) {\n    var toPathShape = path.shape;\n    var splitPropIdx = toPathShape.height > toPathShape.width ? 1 : 0;\n    var propWH = PROP_WH[splitPropIdx];\n    var propXY = PROP_XY[splitPropIdx];\n    var subWH = toPathShape[propWH] / separateCount;\n    var xyCurr = toPathShape[propXY];\n\n    for (var i = 0; i < separateCount; i++, xyCurr += subWH) {\n      var subShape = {\n        x: toPathShape.x,\n        y: toPathShape.y,\n        width: toPathShape.width,\n        height: toPathShape.height\n      };\n      subShape[propXY] = xyCurr;\n      subShape[propWH] = i < separateCount - 1 ? subWH : toPathShape[propXY] + toPathShape[propWH] - xyCurr;\n      var splitted = new Rect({\n        shape: subShape\n      });\n      resultPaths.push(splitted);\n    }\n  } else if (path instanceof Sector) {\n    var toPathShape = path.shape;\n    var clockwise = toPathShape.clockwise;\n    var startAngle = toPathShape.startAngle;\n    var endAngle = toPathShape.endAngle;\n    var endAngleNormalized = normalizeRadian(startAngle, toPathShape.endAngle, clockwise);\n    var step = (endAngleNormalized - startAngle) / separateCount;\n    var angleCurr = startAngle;\n\n    for (var i = 0; i < separateCount; i++, angleCurr += step) {\n      var splitted = new Sector({\n        shape: {\n          cx: toPathShape.cx,\n          cy: toPathShape.cy,\n          r: toPathShape.r,\n          r0: toPathShape.r0,\n          clockwise: clockwise,\n          startAngle: angleCurr,\n          endAngle: i === separateCount - 1 ? endAngle : angleCurr + step\n        }\n      });\n      resultPaths.push(splitted);\n    }\n  } else {\n    return duplicateShape(path, separateCount);\n  }\n\n  return resultPaths;\n}\n\nfunction duplicateShape(path, separateCount) {\n  var resultPaths = [];\n\n  if (separateCount <= 0) {\n    return resultPaths;\n  }\n\n  var ctor = path.constructor;\n\n  for (var i = 0; i < separateCount; i++) {\n    var sub = new ctor({\n      shape: clone(path.shape)\n    });\n    resultPaths.push(sub);\n  }\n\n  return resultPaths;\n}\n\nfunction normalizeRadian(start, end, clockwise) {\n  return end + PI2 * Math[clockwise ? 'ceil' : 'floor']((start - end) / PI2);\n}","map":null,"metadata":{},"sourceType":"module"}