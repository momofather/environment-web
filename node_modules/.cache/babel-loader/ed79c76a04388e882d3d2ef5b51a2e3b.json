{"ast":null,"code":"import { normalizeArcAngles } from '../../core/PathProxy';\nvar PI = Math.PI;\nvar PI2 = PI * 2;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar mathACos = Math.acos;\nvar mathATan2 = Math.atan2;\nvar mathAbs = Math.abs;\nvar mathSqrt = Math.sqrt;\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar e = 1e-4;\n\nfunction intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var x10 = x1 - x0;\n  var y10 = y1 - y0;\n  var x32 = x3 - x2;\n  var y32 = y3 - y2;\n  var t = y32 * x10 - x32 * y10;\n\n  if (t * t < e) {\n    return;\n  }\n\n  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;\n  return [x0 + t * x10, y0 + t * y10];\n}\n\nfunction computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {\n  var x01 = x0 - x1;\n  var y01 = y0 - y1;\n  var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);\n  var ox = lo * y01;\n  var oy = -lo * x01;\n  var x11 = x0 + ox;\n  var y11 = y0 + oy;\n  var x10 = x1 + ox;\n  var y10 = y1 + oy;\n  var x00 = (x11 + x10) / 2;\n  var y00 = (y11 + y10) / 2;\n  var dx = x10 - x11;\n  var dy = y10 - y11;\n  var d2 = dx * dx + dy * dy;\n  var r = radius - cr;\n  var s = x11 * y10 - x10 * y11;\n  var d = (dy < 0 ? -1 : 1) * mathSqrt(mathMax(0, r * r * d2 - s * s));\n  var cx0 = (s * dy - dx * d) / d2;\n  var cy0 = (-s * dx - dy * d) / d2;\n  var cx1 = (s * dy + dx * d) / d2;\n  var cy1 = (-s * dx + dy * d) / d2;\n  var dx0 = cx0 - x00;\n  var dy0 = cy0 - y00;\n  var dx1 = cx1 - x00;\n  var dy1 = cy1 - y00;\n\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {\n    cx0 = cx1;\n    cy0 = cy1;\n  }\n\n  return {\n    cx: cx0,\n    cy: cy0,\n    x01: -ox,\n    y01: -oy,\n    x11: cx0 * (radius / r - 1),\n    y11: cy0 * (radius / r - 1)\n  };\n}\n\nexport function buildPath(ctx, shape) {\n  var radius = mathMax(shape.r, 0);\n  var innerRadius = mathMax(shape.r0 || 0, 0);\n  var hasRadius = radius > 0;\n  var hasInnerRadius = innerRadius > 0;\n\n  if (!hasRadius && !hasInnerRadius) {\n    return;\n  }\n\n  if (!hasRadius) {\n    radius = innerRadius;\n    innerRadius = 0;\n  }\n\n  if (innerRadius > radius) {\n    var tmp = radius;\n    radius = innerRadius;\n    innerRadius = tmp;\n  }\n\n  var clockwise = !!shape.clockwise;\n  var startAngle = shape.startAngle;\n  var endAngle = shape.endAngle;\n  var arc;\n\n  if (startAngle === endAngle) {\n    arc = 0;\n  } else {\n    var tmpAngles = [startAngle, endAngle];\n    normalizeArcAngles(tmpAngles, !clockwise);\n    arc = mathAbs(tmpAngles[0] - tmpAngles[1]);\n  }\n\n  var x = shape.cx;\n  var y = shape.cy;\n  var cornerRadius = shape.cornerRadius || 0;\n  var innerCornerRadius = shape.innerCornerRadius || 0;\n\n  if (!(radius > e)) {\n    ctx.moveTo(x, y);\n  } else if (arc > PI2 - e) {\n    ctx.moveTo(x + radius * mathCos(startAngle), y + radius * mathSin(startAngle));\n    ctx.arc(x, y, radius, startAngle, endAngle, !clockwise);\n\n    if (innerRadius > e) {\n      ctx.moveTo(x + innerRadius * mathCos(endAngle), y + innerRadius * mathSin(endAngle));\n      ctx.arc(x, y, innerRadius, endAngle, startAngle, clockwise);\n    }\n  } else {\n    var halfRd = mathAbs(radius - innerRadius) / 2;\n    var cr = mathMin(halfRd, cornerRadius);\n    var icr = mathMin(halfRd, innerCornerRadius);\n    var cr0 = icr;\n    var cr1 = cr;\n    var xrs = radius * mathCos(startAngle);\n    var yrs = radius * mathSin(startAngle);\n    var xire = innerRadius * mathCos(endAngle);\n    var yire = innerRadius * mathSin(endAngle);\n    var xre = void 0;\n    var yre = void 0;\n    var xirs = void 0;\n    var yirs = void 0;\n\n    if (cr > e || icr > e) {\n      xre = radius * mathCos(endAngle);\n      yre = radius * mathSin(endAngle);\n      xirs = innerRadius * mathCos(startAngle);\n      yirs = innerRadius * mathSin(startAngle);\n\n      if (arc < PI) {\n        var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);\n\n        if (it_1) {\n          var x0 = xrs - it_1[0];\n          var y0 = yrs - it_1[1];\n          var x1 = xre - it_1[0];\n          var y1 = yre - it_1[1];\n          var a = 1 / mathSin(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);\n          var b = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);\n          cr0 = mathMin(icr, (innerRadius - b) / (a - 1));\n          cr1 = mathMin(cr, (radius - b) / (a + 1));\n        }\n      }\n    }\n\n    if (!(arc > e)) {\n      ctx.moveTo(x + xrs, y + yrs);\n    } else if (cr1 > e) {\n      var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, cr1, clockwise);\n      var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, cr1, clockwise);\n      ctx.moveTo(x + ct0.cx + ct0.x01, y + ct0.cy + ct0.y01);\n\n      if (cr1 < cr) {\n        ctx.arc(x + ct0.cx, y + ct0.cy, cr1, mathATan2(ct0.y01, ct0.x01), mathATan2(ct1.y01, ct1.x01), !clockwise);\n      } else {\n        ctx.arc(x + ct0.cx, y + ct0.cy, cr1, mathATan2(ct0.y01, ct0.x01), mathATan2(ct0.y11, ct0.x11), !clockwise);\n        ctx.arc(x, y, radius, mathATan2(ct0.cy + ct0.y11, ct0.cx + ct0.x11), mathATan2(ct1.cy + ct1.y11, ct1.cx + ct1.x11), !clockwise);\n        ctx.arc(x + ct1.cx, y + ct1.cy, cr1, mathATan2(ct1.y11, ct1.x11), mathATan2(ct1.y01, ct1.x01), !clockwise);\n      }\n    } else {\n      ctx.moveTo(x + xrs, y + yrs);\n      ctx.arc(x, y, radius, startAngle, endAngle, !clockwise);\n    }\n\n    if (!(innerRadius > e) || !(arc > e)) {\n      ctx.lineTo(x + xire, y + yire);\n    } else if (cr0 > e) {\n      var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -cr0, clockwise);\n      var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -cr0, clockwise);\n      ctx.lineTo(x + ct0.cx + ct0.x01, y + ct0.cy + ct0.y01);\n\n      if (cr0 < icr) {\n        ctx.arc(x + ct0.cx, y + ct0.cy, cr0, mathATan2(ct0.y01, ct0.x01), mathATan2(ct1.y01, ct1.x01), !clockwise);\n      } else {\n        ctx.arc(x + ct0.cx, y + ct0.cy, cr0, mathATan2(ct0.y01, ct0.x01), mathATan2(ct0.y11, ct0.x11), !clockwise);\n        ctx.arc(x, y, innerRadius, mathATan2(ct0.cy + ct0.y11, ct0.cx + ct0.x11), mathATan2(ct1.cy + ct1.y11, ct1.cx + ct1.x11), clockwise);\n        ctx.arc(x + ct1.cx, y + ct1.cy, cr0, mathATan2(ct1.y11, ct1.x11), mathATan2(ct1.y01, ct1.x01), !clockwise);\n      }\n    } else {\n      ctx.lineTo(x + xire, y + yire);\n      ctx.arc(x, y, innerRadius, endAngle, startAngle, clockwise);\n    }\n  }\n\n  ctx.closePath();\n}","map":null,"metadata":{},"sourceType":"module"}