{"ast":null,"code":"import { createElement } from './core';\nimport * as util from '../core/util';\nimport Path from '../graphic/Path';\nimport ZRImage from '../graphic/Image';\nimport TSpan from '../graphic/TSpan';\nimport arrayDiff from '../core/arrayDiff';\nimport GradientManager from './helper/GradientManager';\nimport PatternManager from './helper/PatternManager';\nimport ClippathManager, { hasClipPath } from './helper/ClippathManager';\nimport ShadowManager from './helper/ShadowManager';\nimport { path as svgPath, image as svgImage, text as svgText } from './graphic';\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction getSvgProxy(el) {\n  if (el instanceof Path) {\n    return svgPath;\n  } else if (el instanceof ZRImage) {\n    return svgImage;\n  } else if (el instanceof TSpan) {\n    return svgText;\n  } else {\n    return svgPath;\n  }\n}\n\nfunction checkParentAvailable(parent, child) {\n  return child && parent && child.parentNode !== parent;\n}\n\nfunction insertAfter(parent, child, prevSibling) {\n  if (checkParentAvailable(parent, child) && prevSibling) {\n    var nextSibling = prevSibling.nextSibling;\n    nextSibling ? parent.insertBefore(child, nextSibling) : parent.appendChild(child);\n  }\n}\n\nfunction prepend(parent, child) {\n  if (checkParentAvailable(parent, child)) {\n    var firstChild = parent.firstChild;\n    firstChild ? parent.insertBefore(child, firstChild) : parent.appendChild(child);\n  }\n}\n\nfunction remove(parent, child) {\n  if (child && parent && child.parentNode === parent) {\n    parent.removeChild(child);\n  }\n}\n\nfunction removeFromMyParent(child) {\n  if (child && child.parentNode) {\n    child.parentNode.removeChild(child);\n  }\n}\n\nfunction getSvgElement(displayable) {\n  return displayable.__svgEl;\n}\n\nvar SVGPainter = function () {\n  function SVGPainter(root, storage, opts, zrId) {\n    this.type = 'svg';\n    this.refreshHover = createMethodNotSupport('refreshHover');\n    this.pathToImage = createMethodNotSupport('pathToImage');\n    this.configLayer = createMethodNotSupport('configLayer');\n    this.root = root;\n    this.storage = storage;\n    this._opts = opts = util.extend({}, opts || {});\n    var svgDom = createElement('svg');\n    svgDom.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns', 'http://www.w3.org/2000/svg');\n    svgDom.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', 'http://www.w3.org/1999/xlink');\n    svgDom.setAttribute('version', '1.1');\n    svgDom.setAttribute('baseProfile', 'full');\n    svgDom.style.cssText = 'user-select:none;position:absolute;left:0;top:0;';\n    var bgRoot = createElement('g');\n    svgDom.appendChild(bgRoot);\n    var svgRoot = createElement('g');\n    svgDom.appendChild(svgRoot);\n    this._gradientManager = new GradientManager(zrId, svgRoot);\n    this._patternManager = new PatternManager(zrId, svgRoot);\n    this._clipPathManager = new ClippathManager(zrId, svgRoot);\n    this._shadowManager = new ShadowManager(zrId, svgRoot);\n    var viewport = document.createElement('div');\n    viewport.style.cssText = 'overflow:hidden;position:relative';\n    this._svgDom = svgDom;\n    this._svgRoot = svgRoot;\n    this._backgroundRoot = bgRoot;\n    this._viewport = viewport;\n    root.appendChild(viewport);\n    viewport.appendChild(svgDom);\n    this.resize(opts.width, opts.height);\n    this._visibleList = [];\n  }\n\n  SVGPainter.prototype.getType = function () {\n    return 'svg';\n  };\n\n  SVGPainter.prototype.getViewportRoot = function () {\n    return this._viewport;\n  };\n\n  SVGPainter.prototype.getSvgDom = function () {\n    return this._svgDom;\n  };\n\n  SVGPainter.prototype.getSvgRoot = function () {\n    return this._svgRoot;\n  };\n\n  SVGPainter.prototype.getViewportRootOffset = function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  };\n\n  SVGPainter.prototype.refresh = function () {\n    var list = this.storage.getDisplayList(true);\n\n    this._paintList(list);\n  };\n\n  SVGPainter.prototype.setBackgroundColor = function (backgroundColor) {\n    if (this._backgroundRoot && this._backgroundNode) {\n      this._backgroundRoot.removeChild(this._backgroundNode);\n    }\n\n    var bgNode = createElement('rect');\n    bgNode.setAttribute('width', this.getWidth());\n    bgNode.setAttribute('height', this.getHeight());\n    bgNode.setAttribute('x', 0);\n    bgNode.setAttribute('y', 0);\n    bgNode.setAttribute('id', 0);\n    bgNode.style.fill = backgroundColor;\n\n    this._backgroundRoot.appendChild(bgNode);\n\n    this._backgroundNode = bgNode;\n  };\n\n  SVGPainter.prototype.createSVGElement = function (tag) {\n    return createElement(tag);\n  };\n\n  SVGPainter.prototype.paintOne = function (el) {\n    var svgProxy = getSvgProxy(el);\n    svgProxy && svgProxy.brush(el);\n    return getSvgElement(el);\n  };\n\n  SVGPainter.prototype._paintList = function (list) {\n    var gradientManager = this._gradientManager;\n    var patternManager = this._patternManager;\n    var clipPathManager = this._clipPathManager;\n    var shadowManager = this._shadowManager;\n    gradientManager.markAllUnused();\n    patternManager.markAllUnused();\n    clipPathManager.markAllUnused();\n    shadowManager.markAllUnused();\n    var svgRoot = this._svgRoot;\n    var visibleList = this._visibleList;\n    var listLen = list.length;\n    var newVisibleList = [];\n\n    for (var i = 0; i < listLen; i++) {\n      var displayable = list[i];\n      var svgProxy = getSvgProxy(displayable);\n      var svgElement = getSvgElement(displayable);\n\n      if (!displayable.invisible) {\n        if (displayable.__dirty || !svgElement) {\n          svgProxy && svgProxy.brush(displayable);\n          svgElement = getSvgElement(displayable);\n\n          if (svgElement && displayable.style) {\n            gradientManager.update(displayable.style.fill);\n            gradientManager.update(displayable.style.stroke);\n            patternManager.update(displayable.style.fill);\n            patternManager.update(displayable.style.stroke);\n            shadowManager.update(svgElement, displayable);\n          }\n\n          displayable.__dirty = 0;\n        }\n\n        if (svgElement) {\n          newVisibleList.push(displayable);\n        }\n      }\n    }\n\n    var diff = arrayDiff(visibleList, newVisibleList);\n    var prevSvgElement;\n    var topPrevSvgElement;\n\n    for (var i = 0; i < diff.length; i++) {\n      var item = diff[i];\n\n      if (item.removed) {\n        for (var k = 0; k < item.count; k++) {\n          var displayable = visibleList[item.indices[k]];\n          var svgElement = getSvgElement(displayable);\n          hasClipPath(displayable) ? removeFromMyParent(svgElement) : remove(svgRoot, svgElement);\n        }\n      }\n    }\n\n    var prevDisplayable;\n    var currentClipGroup;\n\n    for (var i = 0; i < diff.length; i++) {\n      var item = diff[i];\n\n      if (item.removed) {\n        continue;\n      }\n\n      for (var k = 0; k < item.count; k++) {\n        var displayable = newVisibleList[item.indices[k]];\n        var clipGroup = clipPathManager.update(displayable, prevDisplayable);\n\n        if (clipGroup !== currentClipGroup) {\n          prevSvgElement = topPrevSvgElement;\n\n          if (clipGroup) {\n            prevSvgElement ? insertAfter(svgRoot, clipGroup, prevSvgElement) : prepend(svgRoot, clipGroup);\n            topPrevSvgElement = clipGroup;\n            prevSvgElement = null;\n          }\n\n          currentClipGroup = clipGroup;\n        }\n\n        var svgElement = getSvgElement(displayable);\n        prevSvgElement ? insertAfter(currentClipGroup || svgRoot, svgElement, prevSvgElement) : prepend(currentClipGroup || svgRoot, svgElement);\n        prevSvgElement = svgElement || prevSvgElement;\n\n        if (!currentClipGroup) {\n          topPrevSvgElement = prevSvgElement;\n        }\n\n        gradientManager.markUsed(displayable);\n        gradientManager.addWithoutUpdate(svgElement, displayable);\n        patternManager.markUsed(displayable);\n        patternManager.addWithoutUpdate(svgElement, displayable);\n        clipPathManager.markUsed(displayable);\n        prevDisplayable = displayable;\n      }\n    }\n\n    gradientManager.removeUnused();\n    patternManager.removeUnused();\n    clipPathManager.removeUnused();\n    shadowManager.removeUnused();\n    this._visibleList = newVisibleList;\n  };\n\n  SVGPainter.prototype._getDefs = function (isForceCreating) {\n    var svgRoot = this._svgDom;\n    var defs = svgRoot.getElementsByTagName('defs');\n\n    if (defs.length === 0) {\n      if (isForceCreating) {\n        var defs_1 = svgRoot.insertBefore(createElement('defs'), svgRoot.firstChild);\n\n        if (!defs_1.contains) {\n          defs_1.contains = function (el) {\n            var children = defs_1.children;\n\n            if (!children) {\n              return false;\n            }\n\n            for (var i = children.length - 1; i >= 0; --i) {\n              if (children[i] === el) {\n                return true;\n              }\n            }\n\n            return false;\n          };\n        }\n\n        return defs_1;\n      } else {\n        return null;\n      }\n    } else {\n      return defs[0];\n    }\n  };\n\n  SVGPainter.prototype.resize = function (width, height) {\n    var viewport = this._viewport;\n    viewport.style.display = 'none';\n    var opts = this._opts;\n    width != null && (opts.width = width);\n    height != null && (opts.height = height);\n    width = this._getSize(0);\n    height = this._getSize(1);\n    viewport.style.display = '';\n\n    if (this._width !== width || this._height !== height) {\n      this._width = width;\n      this._height = height;\n      var viewportStyle = viewport.style;\n      viewportStyle.width = width + 'px';\n      viewportStyle.height = height + 'px';\n      var svgRoot = this._svgDom;\n      svgRoot.setAttribute('width', width + '');\n      svgRoot.setAttribute('height', height + '');\n    }\n\n    if (this._backgroundNode) {\n      this._backgroundNode.setAttribute('width', width);\n\n      this._backgroundNode.setAttribute('height', height);\n    }\n  };\n\n  SVGPainter.prototype.getWidth = function () {\n    return this._width;\n  };\n\n  SVGPainter.prototype.getHeight = function () {\n    return this._height;\n  };\n\n  SVGPainter.prototype._getSize = function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root;\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  };\n\n  SVGPainter.prototype.dispose = function () {\n    this.root.innerHTML = '';\n    this._svgRoot = this._backgroundRoot = this._svgDom = this._backgroundNode = this._viewport = this.storage = null;\n  };\n\n  SVGPainter.prototype.clear = function () {\n    var viewportNode = this._viewport;\n\n    if (viewportNode && viewportNode.parentNode) {\n      viewportNode.parentNode.removeChild(viewportNode);\n    }\n  };\n\n  SVGPainter.prototype.toDataURL = function () {\n    this.refresh();\n    var svgDom = this._svgDom;\n    var outerHTML = svgDom.outerHTML || (svgDom.parentNode && svgDom.parentNode).innerHTML;\n    var html = encodeURIComponent(outerHTML.replace(/></g, '>\\n\\r<'));\n    return 'data:image/svg+xml;charset=UTF-8,' + html;\n  };\n\n  return SVGPainter;\n}();\n\nfunction createMethodNotSupport(method) {\n  return function () {\n    util.logError('In SVG mode painter not support method \"' + method + '\"');\n  };\n}\n\nexport default SVGPainter;","map":null,"metadata":{},"sourceType":"module"}